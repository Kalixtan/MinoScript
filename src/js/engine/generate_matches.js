
/* THIS FILE IS NOT FOR EXECUTION !!!!
 * it is for documenting this complex part of the engine that is the generation of specific rule-matching functions
 */


// Cells
// =====

// The generated functions are a specialized case of:
function matchCell()
{
	return (
		   ((level.objects[i] & cell_pattern.objectsPresent) == cell_pattern.objectsPresent)
		&& ((level.objects[i] & cell_pattern.objectsMissing) == 0)
		&& ((level.movements[i] & cell_pattern.movementsPresent) == cell_pattern.movementsPresent)
		&& ((level.movements[i] & cell_pattern.movementsMissing) == 0)
		&& cell_pattern.anyObjectsPresent.every( s => ((level.objects[i] & s) != 0) )
	)
}
// - Note that there is no anyMovementPresent, because the objects in an anyObjectsPresent slot are all in the same layer and thus share the same movement, which has been
//   put in movementsPresent / movementsMissing.
// - Also, there is no anyObjectMissing, because that would correspond to object conditions like 'no single-layer-property', which has been translated into 'no obj1 no obj2...'
//   and put in objectsMissing.
// - The case of 'no aggregate' = 'no obj1 or no obj2 or...' could be dealt easily with a test like:
//   ((level.objects[i] & cell_pattern.aggregateMissing) !== cell_pattern.aggregateMissing)

// Cell Rows
// =========

// This function has been replaced with a direct call to Rule.cellRowMatches[cellRowIndex](this.patterns[cellRowIndex], tuple[cellRowIndex], delta_index),
// i.e. a direct call to the function generated by Rule.generateCellRowMatchesFunction.
function DoesCellRowMatch(delta_index, cellRow, start_cell_index)
{
	var targetIndex = start_cell_index
	for (const cellPattern of cellRow)
	{
		if ( ! cellPattern.matches(targetIndex) )
			return false
		targetIndex += delta_index
	}
	return true
}

// Say cellRow has length 3
// CellRow Matches can be specialized to look something like:
function cellRowMatchesFunctionGenerate(delta_index, cellRow, i)
{
	return cellRow[0].matches(i) && cellRow[1].matches(i+delta_index) && cellRow[2].matches(i+2*delta_index)
}

function DoesCellRowMatchWildCard(delta_index, cellRow, start_cell_index, maxk, mink=0)
{
	var targetIndex = start_cell_index

	for (var j=0; j<cellRow.length; j++)
	{

		var cellPattern = cellRow[j]
		if (cellPattern === ellipsisPattern)
		{
			//BAM inner loop time
			for (var k=mink; k<maxk; k++)
			{
				var targetIndex2 = (targetIndex + delta_index*k + level.n_tiles) % level.n_tiles
				for (var j2=j+1; j2<cellRow.length; j2++)
				{
					cellPattern = cellRow[j2];
					if ( ! cellPattern.matches(targetIndex2) )
						break;
					targetIndex2 += delta_index
				}

				if (j2 >= cellRow.length)
					return true
			}
			break
		}
		else if (!cellPattern.matches(targetIndex))
			break
		targetIndex += delta_index
	}
	return false
}

// Say cellRow has length 3, with a split in the middle
// CellRow Matches WildCards can be specialized to look something like:
function cellRowMatchesWildcardFunctionGenerate(delta_index, cellRow,i, maxk, mink)
{
	var result = []
	var matchfirsthalf = cellRow[0].matches(i)
	if (matchfirsthalf)
	{
		for (var k=mink; k<maxk; k++)
		{
			if (cellRow[2].matches(i+delta_index*k))
			{
				result.push([i,k])
			}
		}
	}
	return result
}

// Say cellRow has length 5, with a split in the middle
// CellRow Matches WildCards can be specialized to look something like:
function cellRowMatchesWildcardFunctionGenerate(delta_index, cellRow, i, maxk, mink)
{
	var result = []
	var matchfirsthalf = cellRow[0].matches(i) && cellRow[1].matches(i+delta_index)
	if (matchfirsthalf)
	{
		for (var k=mink; k<kmaxk; k++)
		{
			if (cellRow[2].matches(i+delta_index*k) && cellRow[2].matches(i+delta_index*(k+1)) )
			{
				result.push([i,k])
			}
		}
	}
	return result
}

